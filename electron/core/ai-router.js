/**
 * TruAi Core - AI Router and Governance
 * Copyright Â© 2026 My Deme, LLC. All rights reserved.
 * Proprietary and confidential - Internal use only
 * 
 * FORENSIC_MARKER: TRUAI_CORE_AI_ROUTER_V1
 */

const AITiers = {
  CHEAP: 'CHEAP',
  MID: 'MID',
  HIGH: 'HIGH'
};

const AIProviders = {
  CHATGPT: 'chatgpt',
  CLAUDE: 'claude',
  COPILOT: 'copilot'
};

class AIRouter {
  constructor(riskEngine) {
    this.riskEngine = riskEngine;
    this.executionLog = [];
  }

  /**
   * Route AI request to appropriate provider based on cost and capability
   * @param {Object} request - AI request details
   * @returns {Object} Routing decision
   */
  route(request) {
    const { task, context, preferredTier } = request;
    
    // Determine task complexity
    const tier = preferredTier || this.determineRequiredTier(task);
    
    // Select provider based on tier
    const provider = this.selectProvider(tier, task);
    
    // Generate forensic watermark
    const forensicId = this.riskEngine.generateForensicId();
    
    const routingDecision = {
      tier,
      provider,
      forensicId,
      timestamp: new Date().toISOString(),
      taskHash: this.hashTask(task)
    };
    
    // Log the routing decision
    this.logExecution(routingDecision);
    
    return routingDecision;
  }

  /**
   * Determine required AI tier based on task complexity
   * @param {string} task - Task description
   * @returns {string} Required tier
   */
  determineRequiredTier(task) {
    const taskLower = task.toLowerCase();
    
    // High-tier indicators
    const highTierPatterns = [
      /generate.*code/i,
      /refactor/i,
      /architecture/i,
      /security.*review/i,
      /production.*deploy/i
    ];
    
    // Mid-tier indicators
    const midTierPatterns = [
      /review/i,
      /analyze/i,
      /optimize/i,
      /test/i
    ];
    
    for (const pattern of highTierPatterns) {
      if (pattern.test(taskLower)) {
        return AITiers.HIGH;
      }
    }
    
    for (const pattern of midTierPatterns) {
      if (pattern.test(taskLower)) {
        return AITiers.MID;
      }
    }
    
    return AITiers.CHEAP;
  }

  /**
   * Select AI provider based on tier and task type
   * @param {string} tier - AI tier
   * @param {string} task - Task description
   * @returns {string} Selected provider
   */
  selectProvider(tier, task) {
    switch (tier) {
      case AITiers.CHEAP:
        return AIProviders.CHATGPT;
      
      case AITiers.MID:
        // Use Claude for analytical tasks
        if (/review|analyze/i.test(task)) {
          return AIProviders.CLAUDE;
        }
        return AIProviders.CHATGPT;
      
      case AITiers.HIGH:
        // Copilot for code generation (subordinate)
        if (/code|generate/i.test(task)) {
          return AIProviders.COPILOT;
        }
        // Claude for complex reasoning
        return AIProviders.CLAUDE;
      
      default:
        return AIProviders.CHATGPT;
    }
  }

  /**
   * Add watermark to AI output
   * @param {string} output - AI-generated output
   * @param {string} forensicId - Forensic ID
   * @returns {string} Watermarked output
   */
  watermarkOutput(output, forensicId) {
    const watermark = `\n/* Generated by TruAi Core - ${forensicId} */\n`;
    
    // Add watermark based on content type
    if (output.includes('```')) {
      // Code block - add as comment
      return output + watermark;
    } else if (output.trim().startsWith('{')) {
      // JSON - add as property
      try {
        const obj = JSON.parse(output);
        obj._truai_forensic_id = forensicId;
        return JSON.stringify(obj, null, 2);
      } catch (e) {
        return output + watermark;
      }
    } else {
      // Plain text - add as footer
      return output + `\n\n[TruAi Core: ${forensicId}]`;
    }
  }

  /**
   * Validate that Copilot operates under TruAi authority
   * @param {Object} copilotRequest - Copilot request
   * @returns {boolean} Whether request is authorized
   */
  validateCopilotRequest(copilotRequest) {
    const { hasForensicId, hasAuthToken, followsGuidelines } = copilotRequest;
    
    // Copilot must have TruAi-issued prompt with forensic ID
    if (!hasForensicId) {
      this.riskEngine.logAuditEvent({
        event: 'COPILOT_UNAUTHORIZED_REQUEST',
        reason: 'Missing forensic ID',
        timestamp: new Date().toISOString()
      });
      return false;
    }
    
    // Must follow governance guidelines
    if (!followsGuidelines) {
      this.riskEngine.logAuditEvent({
        event: 'COPILOT_POLICY_VIOLATION',
        timestamp: new Date().toISOString()
      });
      return false;
    }
    
    return true;
  }

  /**
   * Hash task for logging
   * @param {string} task - Task to hash
   * @returns {string} Task hash
   */
  hashTask(task) {
    // Simple hash (use crypto in production)
    let hash = 0;
    for (let i = 0; i < task.length; i++) {
      const char = task.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16);
  }

  /**
   * Log AI execution
   * @param {Object} decision - Routing decision
   */
  logExecution(decision) {
    this.executionLog.push({
      ...decision,
      id: this.executionLog.length + 1
    });
  }

  /**
   * Get execution log
   * @returns {Array} Execution log entries
   */
  getExecutionLog() {
    return [...this.executionLog];
  }
}

module.exports = { AIRouter, AITiers, AIProviders };
